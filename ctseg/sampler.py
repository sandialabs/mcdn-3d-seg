from abc import ABC, abstractmethod
import itertools
import logging
import random

import numpy as np

from ctseg.ctutil.utils import get_class


logger = logging.getLogger(__name__)


class Sampler(ABC):
    def __init__(self, chunk_shape=(240, 240, 240)):
        self._chunk_shape = tuple(chunk_shape)

    @property
    def chunk_shape(self):
        """The 'shape' tuple of the chunks generated by this sampler"""
        return self._chunk_shape

    @property
    def ndim(self):
        """The expected number of dimensions of the data to be sampled"""
        return len(self._chunk_shape)

    @abstractmethod
    def select_keys(self, keys):
        """Select a subset of the keys
        training: random subset
        inference: first key
        """
        pass

    def select_chunks(self, samples, *args, **kwargs):
        """Generate the start/end indices of chunk slices

        Args:
            samples: a dictionary of (key, x) pairs where:
                x (array-like): matches the ndims of this sampler's chunk_shape

        Returns:
            a list of tuples of tuples

            Output for a 3D volume:
            [
                ((x_start_1, x_end_1), (y_start_1, y_end_1), (z_start_1, z_end_1)),
                ((x_start_2, x_end_2), (y_start_2, y_end_2), (z_start_2, z_end_2)),
                ((x_start_3, x_end_3), (y_start_3, y_end_3), (z_start_3, z_end_3)),
            ]
        """
        return [
            (key, chunk)
            for key, sample in samples.items()
            for chunk in self._select_chunks_one_sample(sample)
        ]

    @classmethod
    def from_config(cls, config, chunk_shape=(240, 240, 240)):
        if cls != Sampler:
            raise NotImplementedError("Subclass must implement from_config()")

        sampler_cls = get_class(config["sampler_class"], module_name=__name__)

        return sampler_cls.from_config(config, chunk_shape)

    def _select_chunks_one_sample(self, x):
        """Generate the start/end indices of chunk slices

        Args:
            x (array-like): an array that matches the ndims of this sampler's
                chunk_shape

        Returns:
            a list of tuples of tuples

            Output for a 3D volume:
            [
                ((x_start_1, x_end_1), (y_start_1, y_end_1), (z_start_1, z_end_1)),
                ((x_start_2, x_end_2), (y_start_2, y_end_2), (z_start_2, z_end_2)),
                ((x_start_3, x_end_3), (y_start_3, y_end_3), (z_start_3, z_end_3)),
            ]
        """
        if x.ndim != self.ndim:
            raise ValueError(f"Mismatched ndims: Expected {self.ndim} Actual {x.ndim}")

        # tuples of start indices per chunk
        chunk_starts = self._generate_chunk_starts(x)

        # pair ends with starts
        return [
            tuple(
                (strt, strt + dim) for strt, dim in zip(chunk_start, self._chunk_shape)
            )
            for chunk_start in chunk_starts
        ]

    @abstractmethod
    def _generate_chunk_starts(self, x):
        """Returns an iterable of tuples of start indices per axis

        Example output for a 3D volume:
            [
                (x_start_1, y_start_1, z_start_1),
                (x_start_2, y_start_2, z_start_2),
                (x_start_3, y_start_3, z_start_3),
            ]
        """
        pass

    def _get_max_start_idxs(self, x):
        """max chunk start indices in each dimension"""
        return tuple(
            data_size - chunk_size
            for data_size, chunk_size in zip(x.shape, self._chunk_shape)
        )


class OverlapSampler(Sampler):
    def __init__(self, chunk_shape=(240, 240, 240), stride=240):
        super().__init__(chunk_shape=chunk_shape)

        if any(stride > s for s in self._chunk_shape):
            raise ValueError(
                f"Invalid stride {stride} larger than chunk_shape: {self._chunk_shape}"
            )

        self._stride = stride

    def select_keys(self, keys):
        return keys[:1]

    @classmethod
    def from_config(cls, config, chunk_shape=(240, 240, 240)):
        return cls(chunk_shape=chunk_shape, stride=config["overlap_stride"])

    def _generate_chunk_starts(self, x):
        max_start_idxs = self._get_max_start_idxs(x)

        # each array is the starts for that axis
        starts = [
            np.minimum(range(0, max_start + self._stride, self._stride), max_start)
            for max_start in max_start_idxs
        ]

        # all combinations of starts across dims
        return itertools.product(*starts)


class TrainSampler(Sampler):
    def __init__(
        self,
        chunk_shape=(240, 240, 240),
        n_samples_per_epoch=3,
        n_chunks_per_sample=100,
    ):
        super().__init__(chunk_shape=chunk_shape)
        self._n_samples_per_epoch = n_samples_per_epoch
        self._n_chunks_per_sample = n_chunks_per_sample

    def select_keys(self, keys):
        n_samples = min(len(keys), self._n_samples_per_epoch)
        return np.random.choice(keys, size=n_samples, replace=False)

    @classmethod
    def from_config(cls, config, chunk_shape=(240, 240, 240)):
        return cls(
            chunk_shape=chunk_shape,
            n_samples_per_epoch=config["n_samples_per_epoch"],
            n_chunks_per_sample=config["n_chunks_per_sample"],
        )


class RandomSampler(TrainSampler):
    def select_chunks(self, samples, *args, **kwargs):
        chunks = super().select_chunks(samples)
        random.shuffle(chunks)
        return chunks

    def _generate_chunk_starts(self, x):
        max_start_idxs = self._get_max_start_idxs(x)

        chunk_starts = []
        for _ in range(self._n_chunks_per_sample):
            chunk_starts.append(
                np.random.randint(max_start + 1) for max_start in max_start_idxs
            )

        return chunk_starts


class BattleShipSampler(TrainSampler):
    def select_chunks(self, samples, battleships, *args, **kwargs):
        """Generate the start/end indices of chunk slices

        Args:
            samples: a dictionary of (key, x) pairs where:
                x (array-like): matches the ndims of this sampler's chunk_shape

        Returns:
            a list of tuples of tuples

            Output for a 3D volume:
            [
                ((x_start_1, x_end_1), (y_start_1, y_end_1), (z_start_1, z_end_1)),
                ((x_start_2, x_end_2), (y_start_2, y_end_2), (z_start_2, z_end_2)),
                ((x_start_3, x_end_3), (y_start_3, y_end_3), (z_start_3, z_end_3)),
            ]
        """
        chunks = [
            (key, chunk)
            for key in samples
            for chunk in self._generate_bship_chunks(battleships[key])
        ]
        random.shuffle(chunks)
        return chunks

    def _generate_bship_chunks(self, batteship):
        chunk_starts = batteship.selectVoxelPoints(selections=self._n_chunks_per_sample)

        # pair ends with starts
        return [
            ((strt, strt + dim) for strt, dim in zip(chunk_start, self._chunk_shape))
            for chunk_start in chunk_starts
        ]

    def _generate_chunk_starts(self, x):
        """Unused!"""
        return
